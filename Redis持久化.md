## Redis持久化

Redis提供了多种不同级别的持久化方式：

* RDB持久化可以在指定的时间间隔内生成数据集的时间点快照

* AOF持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行写命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾。Redis还可以在后台对AOF文件进行重写,使得AOF文件的体积不会超出保存数据集状态所需的实际大小。

* Redis还可以同时使用AOF持久化和RDB持久化。在这种情况下，当Redis重启时，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。

* 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

### RDB的优点

* RDB是一个非常紧凑的文件，它保存了Redis在某个时间点上的数据集。这种文件非常适合用于进行备份： 比如说，你可以在最近的24小时内，每个小时备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇到问题，也可以随时将数据集还原到不同版本。

* RDB非常实用与灾难性恢复：它只有一个文件，并且内容都非常紧凑，可以(在加密后)将它传送到别的数据中心

* RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。

* RDB在恢复大数据集时的速度比AOF的恢复速度要快

### RDB的缺点

* 如果你需要尽量避免在服务器故障时丢失数据，那么RDB不适合你。虽然Redis允许你设置不同的保存点来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少5分钟才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能丢失好几分钟的数据。

* 每次保存RDB的时候，Redis都要fork出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，fork可能非常耗时，造成服务器在某毫秒内停止处理客户端；如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至会长达一秒。虽然AOF重写也需要进行fork,但无论AOF重写的执行时间间隔有多长，数据的耐久性都不会有任何损失。


### AOF的优点

* 使用AOF持久化会让Redis变得非常耐久：你可以设置不同的fsync策略，比如无fsync,每秒一次fsync,或者每次执行写入命令时fsync。AOF的默认策略为每秒fsync一次，在这种配置下，Redis依然可以保持良好的性能，并且就算发生故障停止，也最多最会丢失一秒钟的数据。

* AOF文件是一个只进行追加操作的日志文件(append only log)，因此对AOF文件的写入不需要进行seek,即使日志因为某些原因而包含了未写入完整的命令(比如写入时磁盘已满，写入中途停机)，redis-check-aof工具也可以轻易地修复这种问题。

* Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。

### AOF的缺点

* 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积
* 根据所使用的fsync策略，AOF的速度可能会慢于RDB.


### RDB和AOF,如何选择

一般来说，如果想达到足以媲美mysql的数据安全性，应该同时使用两种持久化功能。

如果你非常关心你的数据，但依然可以承受数分钟以内的数据丢失，那么你可以只是用RDB持久化。

不推荐只是使用AOF持久化，因为定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快。



